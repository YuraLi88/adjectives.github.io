<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adjective Order Game</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
                Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            padding: 20px;
            box-sizing: border-box;
        }

        #game-container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        #instructions {
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #555;
        }

        #timer {
            font-size: 1.2em;
            margin-bottom: 20px;
            color: #007bff;
        }

        #blocks-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping if too many blocks for one line */
            justify-content: center;
            align-items: center;
            padding: 10px;
            border: 1px dashed #ccc;
            border-radius: 4px;
            min-height: 60px; /* Ensure drop zone is visible */
            margin-bottom: 20px;
        }

        .category-block {
            padding: 12px 18px;
            margin: 5px;
            color: white;
            border-radius: 5px;
            cursor: grab;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease,
                box-shadow 0.3s ease;
            user-select: none; /* Prevent text selection during drag */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .category-block:active {
            cursor: grabbing;
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .category-block.dragging {
            opacity: 0.5;
        }

        .category-block.clicked {
            /* Slightly different tone for "clicked" */
            filter: brightness(115%);
            box-shadow: 0 0 8px 2px rgba(255, 255, 0, 0.7); /* Yellow glow */
        }

        #results-screen {
            display: none; /* Hidden by default */
            padding: 30px;
            background-color: #e6ffed;
            border: 2px solid #28a745;
            border-radius: 8px;
            text-align: center;
            margin-top: 20px;
        }

        #results-screen h2 {
            color: #28a745;
        }

        #play-again-button {
            padding: 10px 20px;
            font-size: 1em;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 15px;
        }

        #play-again-button:hover {
            background-color: #0056b3;
        }

        /* For drag-over visual cue */
        .drag-over-target {
            background-color: #e0e0e0 !important; /* Light gray to show drop area */
            border: 2px dashed #aaa;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Adjective Order Challenge</h1>
        <p id="instructions">
            Drag the blocks to arrange them in the correct grammatical order.
            Correctly sequenced blocks will glow!
        </p>
        <div id="timer">Time: 0s</div>
        <div id="blocks-container">
            <!-- Blocks will be generated by JavaScript -->
        </div>
    </div>

    <div id="results-screen">
        <h2>Congratulations!</h2>
        <p>You ordered them correctly in <span id="final-time"></span>!</p>
        <button id="play-again-button">Play Again</button>
    </div>

    <script>
        const categoriesData = [
            { text: 'Number', id: 0, color: '#FF6347' }, // Tomato
            { text: 'Opinion', id: 1, color: '#4682B4' }, // SteelBlue
            { text: 'Size / Weight', id: 2, color: '#32CD32' }, // LimeGreen
            { text: 'Age', id: 3, color: '#FFD700' }, // Gold
            { text: 'Shape', id: 4, color: '#6A5ACD' }, // SlateBlue
            { text: 'Color', id: 5, color: '#FF4500' }, // OrangeRed
            { text: 'Participle', id: 6, color: '#20B2AA' }, // LightSeaGreen
            { text: 'Origin', id: 7, color: '#DA70D6' }, // Orchid
            { text: 'Material', id: 8, color: '#B8860B' }, // DarkGoldenRod
            { text: 'Purpose', id: 9, color: '#778899' }, // LightSlateGray
            { text: 'Noun', id: 10, color: '#800080' }, // Purple
        ];

        const blocksContainer = document.getElementById('blocks-container');
        const timerDisplay = document.getElementById('timer');
        const gameContainer = document.getElementById('game-container');
        const resultsScreen = document.getElementById('results-screen');
        const finalTimeDisplay = document.getElementById('final-time');
        const playAgainButton = document.getElementById('play-again-button');

        let timerInterval;
        let seconds = 0;
        let draggableItem = null;

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function startTimer() {
            seconds = 0;
            timerDisplay.textContent = 'Time: 0s';
            clearInterval(timerInterval); // Clear any existing timer
            timerInterval = setInterval(() => {
                seconds++;
                timerDisplay.textContent = `Time: ${seconds}s`;
            }, 1000);
        }

        function stopTimer() {
            clearInterval(timerInterval);
        }

        function createBlock(category) {
            const block = document.createElement('div');
            block.classList.add('category-block');
            block.textContent = category.text;
            block.style.backgroundColor = category.color;
            block.dataset.id = category.id;
            block.draggable = true;

            block.addEventListener('dragstart', handleDragStart);
            block.addEventListener('dragend', handleDragEnd);

            return block;
        }

        function handleDragStart(e) {
            draggableItem = this;
            this.classList.add('dragging');
            // e.dataTransfer.setData('text/plain', this.dataset.id); // Not strictly needed if using draggableItem
        }

        function handleDragEnd() {
            this.classList.remove('dragging');
            draggableItem = null;
            // Remove any lingering drag-over-target classes
            document
                .querySelectorAll('.drag-over-target')
                .forEach((el) => el.classList.remove('drag-over-target'));
        }

        function handleDragOver(e) {
            e.preventDefault(); // Necessary to allow dropping
            const afterElement = getDragAfterElement(blocksContainer, e.clientX);
            const currentTarget = e.target.closest('.category-block');

            // Add visual cue to the block we are hovering over
            document
                .querySelectorAll('.category-block')
                .forEach((block) => block.classList.remove('drag-over-target'));

            if (currentTarget && currentTarget !== draggableItem) {
                currentTarget.classList.add('drag-over-target');
            } else if (!currentTarget && afterElement === null && draggableItem) {
                // If dragging to the end of the container
                const lastChild = blocksContainer.lastElementChild;
                if (lastChild && lastChild !== draggableItem) {
                     // No specific target, but could highlight container or last element
                }
            }
        }

        function getDragAfterElement(container, x) {
            const draggableElements = [
                ...container.querySelectorAll(
                    '.category-block:not(.dragging)',
                ),
            ];

            return draggableElements.reduce(
                (closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = x - box.left - box.width / 2;
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                },
                { offset: Number.NEGATIVE_INFINITY },
            ).element;
        }

        function handleDrop(e) {
            e.preventDefault();
            if (!draggableItem) return;

            const afterElement = getDragAfterElement(blocksContainer, e.clientX);
            if (afterElement == null) {
                blocksContainer.appendChild(draggableItem);
            } else {
                blocksContainer.insertBefore(draggableItem, afterElement);
            }
            checkSequenceAndWin();
        }

        function checkSequenceAndWin() {
            const currentBlocks = [
                ...blocksContainer.querySelectorAll('.category-block'),
            ];
            let allCorrect = true;
            let correctInSequenceCount = 0;

            currentBlocks.forEach((block, index) => {
                const blockId = parseInt(block.dataset.id);
                let isClicked = false;

                if (index === 0) {
                    if (blockId === 0) {
                        isClicked = true;
                    }
                } else {
                    const prevBlockId = parseInt(
                        currentBlocks[index - 1].dataset.id,
                    );
                    if (blockId === prevBlockId + 1) {
                        isClicked = true;
                    }
                }

                if (isClicked) {
                    block.classList.add('clicked');
                } else {
                    block.classList.remove('clicked');
                }

                // For overall win condition, check absolute correct position
                if (blockId !== index) {
                    allCorrect = false;
                }
            });

            if (allCorrect && currentBlocks.length === categoriesData.length) {
                stopTimer();
                gameContainer.style.display = 'none';
                resultsScreen.style.display = 'block';
                finalTimeDisplay.textContent = `${seconds}s`;
            }
        }

        function initGame() {
            gameContainer.style.display = 'block';
            resultsScreen.style.display = 'none';
            blocksContainer.innerHTML = ''; // Clear previous blocks

            const shuffledCategories = [...categoriesData];
            shuffleArray(shuffledCategories);

            shuffledCategories.forEach((category) => {
                const blockElement = createBlock(category);
                blocksContainer.appendChild(blockElement);
            });

            // Add drag listeners to the container itself
            blocksContainer.addEventListener('dragover', handleDragOver);
            blocksContainer.addEventListener('drop', handleDrop);

            startTimer();
            checkSequenceAndWin(); // Initial check for any pre-clicked states (e.g. if first item is #0)
        }

        playAgainButton.addEventListener('click', initGame);

        // Start the game on load
        initGame();
    </script>
</body>
</html>